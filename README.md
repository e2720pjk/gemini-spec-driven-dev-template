# Gemini Spec-Driven Dev Template

## ‚ö†Ô∏è Â∞àÊ°àÂÅúÊ≠¢Êõ¥Êñ∞ÈÄöÁü• / Project Discontinuation Notice

**‰∏≠Êñá**ÔºöÊú¨Â∞àÊ°àÂ∑≤ÂÅúÊ≠¢Êõ¥Êñ∞ÂíåÁ∂≠Ë≠∑„ÄÇÊàëÂÄëÂº∑ÁÉàÂª∫Ë≠∞ÊÇ®‰ΩøÁî®Êõ¥ÊàêÁÜü‰∏îÊåÅÁ∫åÁ∂≠Ë≠∑ÁöÑ **[cc-sdd](https://github.com/gotalab/claude-code-spec)** Â∞àÊ°àÔºåÈÄôÊòØÊú¨Â∞àÊ°àÁöÑÂéüÂßãÂïüÁôº‰æÜÊ∫êÔºåÂäüËÉΩÊõ¥ÂÆåÊï¥‰∏îÊîØÊè¥Â§öÁ®Æ AI ÈñãÁôºÂ∑•ÂÖ∑„ÄÇ

**English**: This project has been discontinued and is no longer maintained. We strongly recommend using the more mature and actively maintained **[cc-sdd](https://github.com/gotalab/claude-code-spec)** project, which is the original inspiration for this template and offers more complete functionality with support for multiple AI development tools.

### üöÄ Êé®Ëñ¶Êõø‰ª£ÊñπÊ°à / Recommended Alternative

**cc-sdd** Êèê‰æõÔºö
- ü§ñ **Â§ö AI Â∑•ÂÖ∑ÊîØÊè¥**ÔºöClaude Code„ÄÅCursor IDE„ÄÅGemini CLI
- üåê **Â§öË™ûË®ÄÊîØÊè¥**Ôºö12Á®ÆË™ûË®ÄÔºàËã±Êñá„ÄÅÊó•Êñá„ÄÅÁπÅÈ´î‰∏≠Êñá„ÄÅÁ∞°È´î‰∏≠Êñá„ÄÅË•øÁè≠ÁâôÊñá„ÄÅËë°ËêÑÁâôÊñá„ÄÅÂæ∑Êñá„ÄÅÊ≥ïÊñá„ÄÅ‰øÑÊñá„ÄÅÁæ©Â§ßÂà©Êñá„ÄÅÈüìÊñá„ÄÅÈòøÊãâ‰ºØÊñáÔºâ
- ‚ú® **‰∏ÄÈçµÂÆâË£ù**Ôºö`npx cc-sdd@latest`
- üìã **ÂÆåÊï¥ÁöÑ AI-DLC Â∑•‰ΩúÊµÅÁ®ã**ÔºöË¶ÅÊ±Ç ‚Üí Ë®≠Ë®à ‚Üí ‰ªªÂãô ‚Üí ÂØ¶‰Ωú
- üéØ **Â∞àÊ°àË®òÊÜ∂È´î**ÔºöAI Â≠∏ÁøíÊÇ®ÁöÑÁ®ãÂºèÁ¢ºÂ∫´„ÄÅÊ®°ÂºèÂíåÂÅèÂ•Ω
- üìö **Kiro IDE Áõ∏ÂÆπÊÄß**ÔºöÂèØËàá Kiro IDE ÁÑ°Á∏´Êï¥Âêà

**cc-sdd** offers:
- ü§ñ **Multi-AI Tool Support**: Claude Code, Cursor IDE, Gemini CLI
- üåê **Multi-Language Support**: 12 languages (English, Japanese, Traditional Chinese, Chinese, Spanish, Portuguese, German, French, Russian, Italian, Korean, Arabic)
- ‚ú® **One-Command Installation**: `npx cc-sdd@latest`
- üìã **Complete AI-DLC Workflow**: Requirements ‚Üí Design ‚Üí Tasks ‚Üí Implementation
- üéØ **Project Memory**: AI learns your codebase, patterns, and preferences
- üìö **Kiro IDE Compatibility**: Seamless integration with Kiro IDE

### Âø´ÈÄüÈñãÂßã / Quick Start

```bash
# ÂÆâË£ù cc-sdd / Install cc-sdd
npx cc-sdd@latest

# ÊîØÊè¥Â§öÁ®ÆÈÅ∏È†Ö / Multiple options supported
npx cc-sdd@latest --lang zh-TW --gemini-cli  # ÁπÅÈ´î‰∏≠Êñá + Gemini CLI
npx cc-sdd@latest --lang ja --cursor         # Êó•Êñá + Cursor IDE
```

‰∫ÜËß£Êõ¥Â§öË´ãË®™ÂïèÔºö[cc-sdd GitHub Repository](https://github.com/gotalab/cc-sdd)

---

## üìö Ê≠∑Âè≤Ë≥áÊñô / Archive Documentation

> ‚ö†Ô∏è **Ê≥®ÊÑè**Ôºö‰ª•‰∏ãÂÖßÂÆπÁÇ∫ÂéüÂ∞àÊ°àÁöÑÊ≠∑Âè≤ÊñáÊ™îÔºåÂÉÖ‰æõÂèÉËÄÉ„ÄÇÂª∫Ë≠∞‰ΩøÁî®‰∏äËø∞Êé®Ëñ¶ÁöÑ cc-sdd Â∞àÊ°à„ÄÇ
>
> **Notice**: The following content is archived documentation from the original project, provided for reference only. Please use the recommended cc-sdd project above.

> üåê **Language**: [English](README.md) | [ÁπÅÈ´î‰∏≠Êñá](README_zh-TW.md)

---

## English

### Quick Start

To get started with the Gemini Spec-Driven Dev Template, follow these steps:

1. **Integrate into Your Project**
   Copy the `.gemini/`, `.kiro/`, and `GEMINI.md` from this template into the root directory of your target project.

2. **(Optional) Configure Workflow**
   Edit `.kiro/config.json` to set your preferred `approval_mode` (e.g., `"implicit"` for streamlined, or `"interactive"` for explicit confirmation).

3. **Launch Gemini in Your Project Directory**
   From your project's root directory, launch Gemini via the terminal.

   ```bash
   gemini
   ```

4. **Set Project Language and Initial Steering**
   Run the recommended first step for any new project. This command initializes or updates the project's high-level goals and architecture, including setting the default language.

   ```bash
   /spec:steering
   ```

5. **Initialize Your First Feature**
   Start your first feature specification by providing a detailed description. This creates the necessary directory structure and metadata files.

   ```bash
   /spec:init "A detailed description of the feature you want to build."
   ```

---

## Table of Contents

* [Gemini Spec-Driven Dev Template](#gemini-spec-driven-dev-template)
  * [English](#english)
    * [Quick Start](#quick-start)
  * [Table of Contents](#table-of-contents)
    * [Project Overview](#project-overview)
    * [The Role of `GEMINI.md` and Multilingual Interaction](#the-role-of-geminimd-and-multilingual-interaction)
    * [Configurable Workflow](#configurable-workflow)
    * [Template Structure](#template-structure)
    * [Step-by-Step Guide](#step-by-step-guide)
    * [Effective Use of Examples](#effective-use-of-examples)
    * [Best Practices](#best-practices)
    * [Document and Configuration Relationships](#document-and-configuration-relationships)
    * [Functional Comparison with `claude-code-spec`](#functional-comparison-with-claude-code-spec)

---

### Project Overview

This project, gemini-spec-driven-dev-template, is a re-implementation and adaptation of the powerful spec-driven
development workflow from the claude-code-spec project, brought into the Gemini CLI ecosystem. Our goal is to replicate
that seamless, automated, and reliable development process using the native capabilities of the Gemini CLI, particularly
its custom commands and tool execution features.

As a starter kit and a powerful extension for the Gemini CLI, this template provides a structured, command-driven
workflow for software development. It guides you from a high-level feature idea to a detailed, and now executable,
implementation plan (via the new /spec:run-tasks command) through a series of automated steps. This ensures
consistency, quality, and clear documentation throughout the development lifecycle.

* Inspired by: [claude-code-spec](https://github.com/gotalab/claude-code-spec)

---

### The Role of `GEMINI.md` and Multilingual Interaction

This template includes a GEMINI.md file, which acts as the central brain for the AI agent. It contains a detailed set
of instructions that define the agent's behavior, workflow, and logic.

A key feature of this logic is multilingual support. The recommended entry point for language configuration is now the
/spec:steering command, which sets the project's default language stored in .kiro/config.json. All subsequent commands,
including /spec:init, will automatically read and use this setting to maintain consistent multilingual interactions.

---

### Configurable Workflow

This template now supports both implicit and interactive approval workflows. You can switch between them by editing the
.kiro/config.json file.

* `"approval_mode": "implicit"` (Default): The original, streamlined workflow where running the next command (e.g.,
  /spec:design) automatically approves the previous stage.
* `"approval_mode": "interactive"`: A more deliberate workflow where the agent will ask for your explicit [y/N]
  confirmation before proceeding to the next stage, similar to the original claude-code-spec.

---

### Template Structure

This template provides a structured environment for spec-driven development. Here's an overview of the key directories
and files:

```bash
gemini-spec-driven-dev-template/
‚îú‚îÄ‚îÄ .gemini/                     # Gemini CLI commands and scripts
‚îÇ   ‚îú‚îÄ‚îÄ commands/                # Custom commands (e.g., /spec:init, /spec:design)
‚îÇ   ‚îî‚îÄ‚îÄ scripts/                 # Helper scripts (e.g., calculate_progress.py)
‚îú‚îÄ‚îÄ .kiro/                       # Specification files and configuration
‚îÇ   ‚îú‚îÄ‚îÄ config.json              # Workflow configuration (e.g., approval_mode, language)
‚îÇ   ‚îú‚îÄ‚îÄ specs/                   # Generated specification documents for features
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [feature-name]/      # Feature-specific directory
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ requirements.md  # Feature requirements
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ design.md        # Technical design
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ tasks.md         # Implementation tasks
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ spec.json        # Feature metadata
‚îÇ   ‚îî‚îÄ‚îÄ steering/                # Project-wide steering documents
‚îÇ       ‚îú‚îÄ‚îÄ product.md           # Product goals and vision
‚îÇ       ‚îú‚îÄ‚îÄ tech.md              # Technical standards and decisions
‚îÇ       ‚îî‚îÄ‚îÄ structure.md         # Project structure guidelines
‚îú‚îÄ‚îÄ example/                     # Example projects demonstrating the workflow
‚îÇ   ‚îî‚îÄ‚îÄ blog-post-generator/     # A complete, functional example project
‚îú‚îÄ‚îÄ GEMINI.md                    # Core instructions and behavior for the Gemini agent
‚îú‚îÄ‚îÄ README.md                    # This document
‚îî‚îÄ‚îÄ ...                          # Other project files (e.g., .gitignore, CHANGELOG.md)
```

---

### Step-by-Step Guide

Follow this sequence to develop a feature from scratch using the Gemini Spec-Driven Dev Template:

#### Workflow Overview

```mermaid
graph TD
    A[Start] --> B[spec:steering - Set Project Direction];
    B --> C[spec:init - Initialize Feature];
    C --> D[spec:requirements - Generate Requirements];
    D --> E[spec:design - Generate Technical Design];
    E --> F[spec:tasks - Generate Implementation Tasks];
    F --> G[spec:run-tasks - Execute Implementation];
    G --> H[spec:status - Check Progress];
    H --> I{Feature Complete?};
    I -- Yes --> J[End];
    I -- No --> F;
```

#### Command Reference

| Command | Purpose | Common Timing |
|---|---|---|
| `/spec:steering` | Establishes or updates the project's high-level goals, architecture, and structure, including setting the default language. | First step for any new project. |
| `/spec:init` | Creates the necessary directory structure and metadata files for a new feature. | When starting a new feature. |
| `/spec:requirements` | Generates the `requirements.md` file based on the initial feature description. | After initializing a feature. |
| `/spec:design` | Implicitly approves requirements and generates the `design.md` file. | After reviewing and approving requirements. |
| `/spec:tasks` | Implicitly approves design and generates a detailed `tasks.md` file with a TDD-style checklist for implementation. | After reviewing and approving the design. |
| `/spec:run-tasks` | Automatically executes the coding tasks defined in `tasks.md`, writing and modifying files to build the feature. | When ready to implement the feature. |
| `/spec:status` | Provides a full report on the feature's progress, including automated task completion percentage. | At any point to check progress. |

#### Phase 1: Steering & Initialization

* **0. Set Project Direction (`/spec:steering`)**: This initial command is crucial for defining the project's overarching goals and technical foundation. For new projects, it prompts for a high-level description and generates initial steering documents, also setting the project's default language.

* **0.1. Custom Steering (`/spec:steering-custom`) (Optional)**: Use this command to create specialized steering documents for specific contexts, such as API standards or testing methodologies.

* **1. Initialize Feature (`/spec:init`)**: This command sets up the necessary directory structure and metadata files for your new feature, automatically incorporating the project's language setting.

#### Phase 2: Specification Development

* **2. Generate Requirements (`/spec:requirements`)**: This command generates the `requirements.md` file, outlining the feature's functional and non-functional needs. Review this document carefully before proceeding.

* **3. Generate Design (`/spec:design`)**: This command implicitly approves the requirements and generates the `design.md` file, detailing the technical architecture and solutions. It incorporates best practices and updates project-wide technical standards.

* **4. Generate Tasks (`/spec:tasks`)**: This command implicitly approves the design and generates a detailed `tasks.md` file, providing a TDD-style checklist for the implementation phase.

#### Phase 3: Implementation & Verification

| Command | Action |
|---|---|
| `/spec:run-tasks [feature-name]` | Automatically executes the coding tasks defined in `tasks.md`, writing and modifying files to build the feature. It now also automatically generates and writes related documentation files as needed (e.g., updating README.md). |
| `/spec:status [feature-name]` | At any point, run this command to get a full report on the feature's progress. The report now includes a specific, runnable next command to guide you. |

---

### Effective Use of Examples

The example/ directory is crucial for success. The AI programming assistant performs significantly better when it can
see patterns to follow.

This template includes a fully functional and completed sample project located at:

```bash
example/blog-post-generator/
```

This project demonstrates a complete spec-driven development workflow. For detailed information and usage instructions,
please refer to the README.md file in the example project directory.

#### How to Leverage the Example Project

* **Explore**: Navigate through `example/blog-post-generator/` to understand a complete spec-driven project from requirements
    (`.kiro/specs/blog-post-generator/requirements.md`) to implementation (`src/`).
* **Learn Patterns**: Observe how the code adheres to best practices and project conventions.
* **Replicate**: Use the example as a blueprint for your own features. You can copy its structure and adapt it.
* **Test Drive**: Run the example's tests (`pytest` from `example/blog-post-generator/`) to see a working implementation.

---

### Best Practices

* **Follow the Workflow**: Adhere to the `init` -> `requirements` -> `design` -> `tasks` sequence for consistent results.
* **Steer First**: Run `/spec:steering` for new projects to establish a clear foundation.
* **Review and Refine**: Manually review and edit generated documents (`requirements.md`, `design.md`, `tasks.md`) to ensure they align with your vision.
* **Leverage Examples**: Use the `example/` directory to understand best practices and provide the AI with clear patterns to follow.

---

### Document and Configuration Relationships

Understanding how different files and configurations interact is key to effectively using this template.

#### Document Relationship Diagram

```mermaid
graph TD
    A[User Input] --> B[spec:steering];
    B --> C["config.json"];
    B --> D["product.md"];
    B --> E["tech.md"];
    B --> F["structure.md"];
    
    G[User Input] --> H[spec:init];
    H --> I["config.json"];
    H --> J["spec.json"];
    
    K[User Input] --> L[spec:requirements];
    L --> J;
    L --> M["requirements.md"];
    
    N[User Input] --> O[spec:design];
    O --> M;
    O --> P["design.md"];
    O --> E;
    
    Q[User Input] --> R[spec:tasks];
    R --> P;
    R --> S["tasks.md"];
    
    T[User Input] --> U[spec:run-tasks];
    U --> S;
    U --> V[Codebase changes];
    U --> W["Documentation updates (e.g., README.md)"];
    
    X[User Input] --> Y[spec:status];
    Y --> J;
    Y --> S;
    Y --> Z[Progress report];

    AC["All commands"];
    
    GEMINI[GEMINI.md] -- Defines AI behavior --> AC;
    AC -- Read configuration --> C;
    AC -- Read guidance --> D;
    AC -- Read guidance --> E;
    AC -- Read guidance --> F;
```

* **`GEMINI.md`**: The core instruction file for the Gemini agent, defining its behavior, workflow, and logic. It is the agent‚Äôs ‚Äúbrain.‚Äù
* **`.kiro/config.json`**: Stores project-wide configurations, including approval_mode (implicit/interactive) and the default language for new features.
* **`.kiro/steering/`**: Contains project-level guidance documents (product.md, tech.md, structure.md) defining the project‚Äôs vision, technical standards, and architecture guidelines. These are your project‚Äôs ‚Äúconstitution.‚Äù
* **`.kiro/specs/[feature-name]/`**: This directory contains all generated specification files (requirements.md, design.md, tasks.md) and metadata (spec.json) for a specific feature. These are your feature‚Äôs ‚Äúblueprints.‚Äù
* **`example/`**: Contains fully functional example projects demonstrating the spec-driven workflow and providing the AI with learnable code patterns.

---

## Functional Comparison with `claude-code-spec`

### Progress Tracking

* `claude-code-spec`: Uses event-driven **Hooks** to automatically trigger progress updates in the background after a file is modified. This is a **proactive, push-based** system.
* This Project (Gemini): Implements progress tracking via the `/spec:status` command. When executed, it calls a Python script (`calculate_progress.py`) on-demand to calculate progress without modifying `spec.json`, presenting the real-time status directly.

### Spec Drift Detection

* `claude-code-spec`: Relies on Hooks to trigger LLM analysis in the background when source code changes, providing real-time feedback.
* This Project (Gemini): This feature is not yet supported.
